---
layout: post
title:  "Week3 - day2"
date:   2021-08-17 20:22:30
categories: [ustage]
---

## 1. 개인학습
* pytorch
	
## 2. 필수 과제
* Document 탐색
    * torch.tensor() vs torch.Tensor()
    
    ```
    torch.tensor()는 항상 데이터를 복제합니다. 그래서 data 없이 tensor 생성이 불가능 합니다. -> runtime error
    torch.Tensor()는 객체(class의 instance)를 생성하는 것으로 data 없이도 생성이 가능합니다.
    ```

* pytorch 활용
    * 사칙연산
        * `+` : [torch.add](https://pytorch.org/docs/stable/generated/torch.add.html?highlight=add#torch.add)
        * `-` : [torch.sub](https://pytorch.org/docs/stable/generated/torch.sub.html#torch.sub)
        * `*` : [torch.mul](https://pytorch.org/docs/stable/generated/torch.mul.html#torch.mul)
        * `/` : [torch.div](https://pytorch.org/docs/stable/generated/torch.div.html#torch.div)
    * 인덱싱
* torch.gather 3차원에서 대각선 뽑기!

```python
import torch
import numpy as np
# TODO : 임의의 크기의 3D tensor에서 대각선 요소 가져와 2D로 반환하는 함수를 만드세요! 
def get_diag_element_3D(A):
    # 1. 인덱스 텐서 만들기
    # 1개의 원소에서 뽑을 인덱스 [0,1,2,...]
    idx = torch.tensor([(i % A.shape[2])  for i in range(A.shape[1])])
    #print("idx: 1: ", idx, idx.shape)
    
    # 2. 차원 맞춰주기 [0,1,2] -> [[0], [1], [2]]
    idx = idx.unsqueeze(1).unsqueeze(0)
    #print("idx: unsqueeze: ", idx, idx.shape)
    
    # 3. 원소 개수 만큼 인덱스 복사(확장)
    idx = idx.expand(A.shape[0], A.shape[1], 1) 
    #print("idx: expand: ", idx, idx.shape)
    
    # 4. 대각선값만 뽑아내기
    output = torch.gather(A, 2, idx)
    #print(output.view(A.shape[0], A.shape[1])
    
    # 5. 2차원으로 만든 후 불필요한 부분 slicing
    return output.view(A.shape[0], A.shape[1])[:, :A.shape[2]]
```
* LazyLinear vs Linear
    * 전자는 첫 forward가 불린 후에 initailize 된다.
    * torch.nn.UninitializedParameter class에 속한다.
* custom_model 만들기
    * Tensor vs Parameter
    
    ```
    Parameter를 이용해서 W, b를 만들 경우에만
    output tensor에 gradient를 계산하는 함수인 grad_fn가 생성됩니다
    ```

    * module 분석하기

    ```python
    for name, module in model.named_modules():
        print(f"[ Name ] : {name}\n[ Module ]\n{module}")
        print("-" * 30)

    output
    ------
    [ Name ] : 
    [ Module ]
    Model(
    (ab): Layer_AB(
        (a): Function_A()
        (b): Function_B()
    )
    (cd): Layer_CD(
        (c): Function_C()
        (d): Function_D(
        (c): Function_C()
        )
    )
    )
    ------------------------------
    [ Name ] : ab
    [ Module ]
    Layer_AB(
    (a): Function_A()
    (b): Function_B()
    )
    ------------------------------
    [ Name ] : ab.a
    [ Module ]
    Function_A()
    ------------------------------
    [ Name ] : ab.b
    [ Module ]
    Function_B()
    ------------------------------
    [ Name ] : cd
    [ Module ]
    Layer_CD(
    (c): Function_C()
    (d): Function_D(
        (c): Function_C()
    )
    )
    ------------------------------
    [ Name ] : cd.c
    [ Module ]
    Function_C()
    ------------------------------
    [ Name ] : cd.d
    [ Module ]
    Function_D(
    (c): Function_C()
    )
    ------------------------------
    [ Name ] : cd.d.c
    [ Module ]
    Function_C()
    ------------------------------

    for name, child in model.named_children():
        print(f"[ Name ] : {name}\n[ Children ]\n{child}")
        print("-" * 30)
    
    [ Name ] : ab
    [ Children ]
    Layer_AB(
    (a): Function_A()
    (b): Function_B()
    )
    ------------------------------
    [ Name ] : cd
    [ Children ]
    Layer_CD(
    (c): Function_C()
    (d): Function_D(
        (c): Function_C()
    )
    )
    ------------------------------
    ```

    * parameter 분석하기

    ```python
    for name, parameter in model.named_parameters():
        print(f"[ Name ] : {name}\n[ Parameter ]\n{parameter}")
        print("-" * 30)

    output
    ------
    [ Name ] : ab.b.W1
    [ Parameter ]
    Parameter containing:
    tensor([10.], requires_grad=True)
    ------------------------------
    [ Name ] : ab.b.W2
    [ Parameter ]
    Parameter containing:
    tensor([2.], requires_grad=True)
    ------------------------------

    parameter = model.get_parameter('ab.b.W1')
    ```

    * buffer 정보 확인

    ```python
    for name, buffer in model.named_buffers():
        print(f"[ Name ] : {name}\n[ Buffer ] : {buffer}")
        print("-" * 30)

    buffer = model.get_buffer('cd.c.duck')
    ```

    * doc string

    ```python
    def __doc__(self): 
        구현!
    ```
* hook
    * 프로그램의 실행 로직을 분석하거나
    * 프로그램에 추가적인 기능을 제공하고 싶을 때   

## 3. 피어세션
* pytorch-basic 강의 정리
* 과제 코드 공유
* 우선순위 큐 이론 공유

## 4. 특강
* 라이엇 CTO 님